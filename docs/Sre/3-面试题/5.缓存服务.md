## 使用rabbitmq的场景

（1） 服务间异步通信

（2） 顺序消费

（3） 定时任务

（4） 流量削峰

（5） 解耦（为面向服务的架构（SOA）提供基本的最终一致性实现）



## 工作模式介绍

### 一、 简单模式

功能：一个生产者P发送消息到队列Q,一个消费者C接收

①  生产者实现思路：

创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel向队列中发送消息，关闭通道和连接。

②  消费者实现思路：

创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue, 创建消费者并监听队列，从队列中读取消息。

### 二、 工作模式

功能：一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者只有一个队列

任务队列：避免立即做一个资源密集型任务，必须等待它完成，而是把这个任务安排到稍后再做。我们将任务封装为消息并将其发送给队列。后台运行的工作进程将弹出任务并最终执行作业。当有多个worker同时运行时，任务将在它们之间共享。

### 三、 publish/subscribe发布订阅(共享资源)

功能：一个生产者发送的消息会被多个消费者获取。一个生产者、一个交换机、多个队列、多个消费者。

生产者：可以将消息发送到队列或者是交换机。

消费者：只能从队列中获取消息。

①  生产者实现思路：

创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，使用通道channel创建交换机并指定交换机类型为fanout，使用通道向交换机发送消息，关闭通道和连接。

②  消费者实现思路：

创建连接工厂ConnectionFactory，设置服务地址127.0.0.1，端口号5672，设置用户名、密码、virtual host，从连接工厂中获取连接connection，使用连接创建通道channel，使用通道channel创建队列queue，绑定队列到交换机，设置Qos=1，创建消费者并监听队列，使用手动方式返回完成。可以有多个队列绑定到交换机，多个消费者进行监听。

### 四、 路由模式

该方式一个路由键对应一个消息队列，一个消息队列可以对应多个路由键，一个消息队列对应一个消费者，当一个队列下有多个消费者时，MQ采用的是轮询机制，选取一个消费者消费该队列下的消息，其他消费者则轮空。该模式给消息指明了准确的路线，告诉消息必须按照我制定的路线规则来走，适合于比较简单的场景，缺点是路由规则不够灵活。

### 五、 主题模式

基本思想和路由模式是一样的，只不过路由键支持模糊匹配，符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词，路由规则变得灵活多变，可拓展性非常的强

应用场景：

②  单发送，单接收的应用场景

③  多发送，单接收的应用场景（主要）





## RabbitMQ的三种集群模式



**rabbitmq有三种模式：单机模式，普通集群模式，镜像集群模式**

##### 1）单机模式

就是demo级别的，一般就是你本地启动了玩玩的，没人生产用单机模式

##### 2）普通集群模式

意思就是在**多台机器**上启动**多个rabbitmq实例**，**每个机器启动一个。** 但是你创建的**queue**，只会放在**一个rabbtimq实例**上，但是**每个实例都同步queue的元数据(存放含queue数据的真正实例位置)**。消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。

**这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群。** 因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据，前者有数据拉取的开销，后者导致单实例性能瓶颈。

而且如果那个放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据。

所以这个普通集群比较尴尬了，这就没有什么所谓的高可用性可言了，**这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个queue的读写操作。**





![image-20231103114647802](https://iteshell.oss-cn-beijing.aliyuncs.com/bookshell/operator/image-20231103114647802.png)





##### 3）镜像集群模式

 这种模式，才是所谓的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。





![image-20231103114704564](https://iteshell.oss-cn-beijing.aliyuncs.com/bookshell/operator/image-20231103114704564.png)







镜像集群模式

**镜像集群模式** **好处在于**，你任何一个机器宕机了，没事儿，别的机器都可以用。 **坏处在于**

- 第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！
- 第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue

那么怎么开启这个镜像集群模式呢？我这里简单说一下，其实很简单rabbitmq有很好的管理控制台，我们可以在后台新增一个策略，这个策略是镜像集群模式的策略，可以指定要求数据同步到所有节点，也可以要求同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。[RabbitMQ镜像集群入门](https://cloud.tencent.com/developer/tools/blog-entry?target=https%3A%2F%2Flinks.jianshu.com%2Fgo%3Fto%3Dhttps%3A%2F%2Fwww.cnblogs.com%2FLiangSW%2Fp%2F6242280.html)







![image-20231103114723335](https://iteshell.oss-cn-beijing.aliyuncs.com/bookshell/operator/image-20231103114723335.png)







